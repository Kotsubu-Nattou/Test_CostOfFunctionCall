/***********************************************************************************************************
◎値渡し、参照渡し、ポインタ渡しの速度比較

値渡しは、渡した引数が「仮引数」に成るときに、オブジェクトの「コピー生成」が行われる。
対して参照渡しとポインタ渡しは、オブジェクトの「先頭アドレス」とそれを受け取るポインタだけで済む。
一見、値渡しが遅いように思うが、参照渡し等にはアドレスの解消コストがかかっている。これは、
関数内部で参照先の値にアクセスするときも同様。
また、オブジェクトが小さい場合は、逆に値渡しする方が低コストになることがある。
ポイントは仮引数の「生成のコスト、アクセスのコスト」の2つ

    ・オブジェクト小。関数内でのアクセス少  ---  値渡し〇  参照渡し△  ポインタ渡し△   // どれでもいい
    ・オブジェクト小。関数内でのアクセス多  ---  値渡し◎  参照渡し✖  ポインタ渡し✖   // 値渡しが向く
    ・オブジェクト大。関数内でのアクセス少  ---  値渡し✖  参照渡し◎  ポインタ渡し◎   // 基本参照渡し
    ・オブジェクト大。関数内でのアクセス多  ---  値渡し✖  参照渡し〇  ポインタ渡し〇   // 同上


◎メモ
テスト環境: Windows10Pro, CPU Core i5 3.4GHz, Mem 12GB, VGA GeForce 1070, VS 2019, OpenSiv3D 0.3.2
コンパイル構成はRelease（最適化無し）で行う。
最適化を有効にすると関数内の処理が端折られてしまう。
おそらく、このコンパイル構成がコードを端折られず、このcpp以外の部分（Siv3Dなど）が
Release向けビルドとなり、純粋なテストができると思われる。
「最適化無しで一番速いものが、結局は最適化しても速いはず」

TrialMaxで試行回数を増やせば、結果が安定する。（はずなのだが...）
AccessMaxで、引数の「受け渡し」と関数内「アクセス」の比率を変えてみる。
上記の組み合わせを色々試した結果、なぜかTraialMaxの数次第で速度比が変わることがあった。
また、特定の組み合わせで、それまでの「傾向にそぐわない結果」になる事があった。
これらは、おそらくキャッシュなどの影響だと思われる。


・s3d::Vec2型のテスト
    ・Debug
        結果 --- バランスを変えても、どれも同じような速度となった
        おそらく、デバッグ機能などのオーバーヘッドが大きすぎて差が見えなくなったと思われる。

    ・Release（最適化なし）
        結果 --- AccessMax = 1     --- 予想通り、値渡しが約1.5倍遅い（参照とポインタは僅差）
                 AccessMax = 5     --- だんだん差が無くなる
                 AccessMax = 10    --- 逆転して、他より僅かに速い
                 AccessMax = 20    --- 差が広がり、約1.1倍
                 AccessMax = 1000  --- なぜか落ち着いてきて約1.07倍
                 AccessMax = 10000 --- 約1.04倍
    ・結論
      おそらくAccessMaxが20くらいからは不安定（システムやキャッシュの状況で左右しそう）
      関数で5回以下しか使わないものは、参照渡しやポインタ渡しを検討する。
      この5回というのは「ループ処理」以外ではあまり見かけない。よって
        「関数でループ処理に使わないものは、参照orポインタ渡しが良い」
      または、
        「関数で酷使するものは、値渡しが良い」

      呼び出しコストの観点で言えば、
        「関数で数回しか使わないものを値渡しにして、鬼のように呼ぶのはNG」


・s3d::ColorF型のテスト
    Vec2型テストの傾向のまま、より速度差が著明になった
    AccessMax = 1    --- 値渡しが他より約1.8倍も遅い（参照とポインタは僅差）
    AccessMax = 30   --- この辺りで差が無くなる
    AccessMax = 100  --- 逆転して、他より僅かに速い
    AccessMax = 300  --- 差が広がり、約1.1倍（この辺りのテスト結果は不安定）
    AccessMax = 500  --- なぜか落ち着いてきて約1.07倍
    AccessMax = 1000 --- 僅かに速い

    ・結論
    テスト結果がVec2と比べて不安定（AccessMaxが100くらいから著明）
    AccessMaxが1のときの速度が、Vec2のときより遅いのは、オブジェクトサイズが
    Vec2より大きいからだと思われる（不安定なのも関係してそう）
    また、差が無くなってくるのが30と多い。よって
        「ほぼほぼ参照渡しかポインタ渡しが良い」


・組み込み型（int）のテスト
    AccessMax = 1     --- 差が無い
    AccessMax = 1000  --- 値渡しが約1.1倍速い（参照とポインタは僅差）
    AccessMax = 10000 --- 同上
    AccessMaxが1回で既に差が無く、速度だけで言えば
        「値渡し以外の方法にする理由は無し」


◎さいごに
    テスト結果は、その時々の環境に左右されるため参考程度に。特に「差が無くなる」ポイント以降。

    また、実際の運用では、
    値を変えない全ての参照は、きちんと「const修飾」する。
    引数で値を返すものは、「ポインタ渡し」にして、一見してそれと分かるようにする
***********************************************************************************************************/

# include <Siv3D.hpp>



// 関数を呼び出す回数
const int64 TrialMax  = 100000000;

// 関数内で「仮引数」にアクセスする回数
const int64 AccessMax = 5;





template<class T>
void val(T v)
{
    T a;
    //T a = 0;  // 組み込み型はこちら
    for (int64 i = 0; i < AccessMax; ++i) {
        a += v;
    }
}



template<class T>
void ref(T& v)
{
    T a;
    //T a = 0;
    for (int64 i = 0; i < AccessMax; ++i) {
        a += v;
    }
}



template<class T>
void ptr(T* v)
{
    T a;
    //T a = 0;
    for (int64 i = 0; i < AccessMax; ++i) {
        a += *v;
    }
}





void Main()
{
    s3d::Stopwatch timer;

    while (System::Update())
    {
        // テストする型を初期化
        Vec2 v = { 1.0, 1.0 };
        //ColorF v(0.001, 0.001);
        //int v = 1;


        // 値渡しテスト
        timer.restart();
        for (int64 i = 0; i < TrialMax; ++i) {
            val(v);
        }
        timer.pause();
        Print(U"Val: ", timer.ms());


        // 参照渡しテスト
        timer.restart();
        for (int64 i = 0; i < TrialMax; ++i) {
            ref(v);
        }
        timer.pause();
        Print(U"Ref: ", timer.ms());


        // ポインタ渡しテスト
        timer.restart();
        for (int64 i = 0; i < TrialMax; ++i) {
            ptr(&v);
        }
        timer.pause();
        Print(U"Ptr: ", timer.ms());
        Print();
    }
}
